<!-- import polymer-element -->
<link rel="import"  href="../../bower_components/polymer/polymer-element.html">

<dom-module id="x-draggable">

	<template strip-whitespace>
		<style>
		
		:host {
			position: absolute;
			display: inline-flex;
			flex-direction: row;
			justify-content: center;
			align-items: center;
			contain: content;
			box-sizing: border-box;
			cursor: pointer;
			user-select: none;
			
			border: 1px dashed lightgray;
		}
		
		:host([selected]) {
			border: 1px solid black;
			/* TODO fazer uso de um mixin para que se possa passar vários atributos por fora do shadow DOM */
		}
		
		::slotted(*) {
			cursor: inherit;
			pointer-events: none;
		}
		</style>
		<slot></slot>
	</template>

	<script>
	class XDraggable extends Polymer.Element {
		static get is() {
			return "x-draggable";
		}
		
		constructor() {
			super();
		}
		
		ready() {
			super.ready();
			
			this.addEventListener("mousedown", XDraggable._onDragstart);
		}
		
		connectedCallback() {
			super.connectedCallback();
		}

		disconnectedCallback() {
			super.disconnectedCallback();
		}
		
		static get properties() {
			return {
				selected : {
					type : Boolean,
					value : false,
					reflectToAttribute : true
				},
				x : {
					type : Number,
					value : 0,
					reflectToAttribute : true,
					observer : "_onChangeX"
				},
				dx : {
					type : Number,
					value : 1,
					reflectToAttribute : true
				},
				y : {
					type : Number,
					value : 0,
					reflectToAttribute : true,
					observer : "_onChangeY"
				},
				dy : {
					type : Number,
					value : 1,
					reflectToAttribute : true
				},
				w : {
					type : Number,
					value : 20,
					reflectToAttribute : true,
					observer : "_onChangeW"
				},
				minw : {
					type : Number,
					value : 10,
					reflectToAttribute : true
				},
				h : {
					type : Number,
					value : 20,
					reflectToAttribute : true,
					observer : "_onChangeH"
				},
				minh : {
					type : Number,
					value : 10,
					reflectToAttribute : true
				},
				z : {
					type : Number,
					value : 0,
					reflectToAttribute : true,
					observer : "_onChangeZ"
				}
			};
		}
		
		_onChangeX(x) {
			this.style.left = `${x}px`;
		}
		
		_onChangeY(y) {
			this.style.top = `${y}px`;
		}
		
		_onChangeW(w) {
			this.w = Math.max(w, this.minw);
			this.style.width = `${this.w}px`;
		}
		
		_onChangeH(h) {
			this.h = Math.max(h, this.minh);
			this.style.height = `${this.h}px`;
		}
		
		_onChangeZ(z) {
			this.style.zIndex = z;
		}
		
		//methods
		move(dx, dy) {
			let newX = this.x + dx;
			let newY = this.y + dy;
			
			if (newX < 0) {
				this.x = 0;
			}
			else if (newX+this.w > this.parentElement.offsetWidth) {
				this.x = this.parentElement.offsetWidth - this.w;
			}
			else {
				this.x = newX;
			}
			
			if (newY < 0) {
				this.y = 0;
			}
			else if (newY+this.h > this.parentElement.offsetHeight) {
				this.y = this.parentElement.offsetHeight - this.h;
			}
			else {
				this.y = newY;
			}
		}
		
		//event listeners
		static _onDragstart(e) {
			if (e.which === 1) {
				e.stopPropagation();
				
				if (!e.target.selected && !e.ctrlKey && !e.shiftKey) {
					document.querySelectorAll("x-draggable[selected]")
						.forEach(element => element.selected = false);
				}
				
				e.target.selected = true;
				
				XDraggable._grabbed = {
					x : e.target.x - e.clientX,
					y : e.target.y - e.clientY,
					target : e.target
				};
				document.addEventListener("mousemove", XDraggable._onDrag);
			}
		}
		
		static _onUnclick(e) {
			document.querySelectorAll("x-draggable[selected]").forEach(element => element.selected = false);
		}
		
		static _onDrag(e) {
			if (XDraggable._grabbed && e.which === 1) {
				let newX = ((e.clientX + XDraggable._grabbed.x)/XDraggable._grabbed.target.dx | 0)*XDraggable._grabbed.target.dx;
				let newY = ((e.clientY + XDraggable._grabbed.y)/XDraggable._grabbed.target.dy | 0)*XDraggable._grabbed.target.dy;
				
				let dx = newX - XDraggable._grabbed.target.x; //target.x e target.y atualizados pela chamada do move abaixo
				let dy = newY - XDraggable._grabbed.target.y;
				
				//criar um x-sandbox para conter os x-draggables
				//notificar o pai que há um evento de drag em andamento para ele tomar as providência de chamar o move em cada elemento selecionado (a seleção pertence ao pai)
				document.querySelectorAll("x-draggable[selected]").forEach( element => element.move(dx, dy) );
			}
		}
		
		static _onDragend(e) {
			if (XDraggable._grabbed && e.which === 1) {
				e.preventDefault();
				XDraggable._grabbed = null;
				document.removeEventListener("mousemove", XDraggable._onDrag);
			}
		}
	}
	
	customElements.define(XDraggable.is, XDraggable);
	
	
	//post definitions
	document.addEventListener("mouseup", XDraggable._onDragend);
	document.addEventListener("mousedown", XDraggable._onUnclick);
	
	XDraggable._grabbed = null;
	</script>

</dom-module>