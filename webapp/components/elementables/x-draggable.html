<!-- import polymer-element -->
<link rel="import"  href="../../bower_components/polymer/polymer-element.html">

<dom-module id="x-draggable">

	<template strip-whitespace>
		<style>
		
		:host {
			position: absolute;
			display: inline-block;
			contain: content;
			padding: calc(var(--holder-size) / 2);
			
			--holder-size: 6px;
		}
		
		#content {
			position: relative;
			
			display: inline-flex;
			flex-direction: row;
			justify-content: center;
			align-items: center;
			
			box-sizing: border-box;
			cursor: pointer;
			user-select: none;
			border: 1px dashed lightgray;
		}
		
		#holders {
			display: none;
			position: absolute;
			width: 100%;
			height: 100%;
		}
		
		#holders > .holder {
			position: absolute;
			display: inline-block;
			background-color: black;
			width: var(--holder-size);
			height: var(--holder-size);
		}
		
		#holders > .holder.top {
			top: calc(var(--holder-size) / -2);
		}
		#holders > .holder.left {
			left: calc(var(--holder-size) / -2);
		}
		#holders > .holder.right {
			right: calc(var(--holder-size) / -2);
		}
		#holders > .holder.bottom {
			bottom: calc(var(--holder-size) / -2);
		}
		#holders > .holder.center {
			left: calc(50% + var(--holder-size) / -2);
		}
		#holders > .holder.middle {
			top: calc(50% + var(--holder-size) / -2);
		}
		
		:host([selected]) #holders {
			display: block;
		}
		
		:host([selected]) #content {
			border: 1px solid black;
			/* TODO fazer uso de um mixin para que se possa passar vários atributos por fora do shadow DOM */
		}
		
		::slotted(*) {
			cursor: inherit;
			pointer-events: none;
		}
		</style>
		<div id="content">
			<slot></slot>
			<div id="holders">
				<div class="holder top left"></div>
				<div class="holder top center"></div>
				<div class="holder top right"></div>
				<div class="holder left middle"></div>
				<div class="holder right middle"></div>
				<div class="holder bottom left"></div>
				<div class="holder bottom center"></div>
				<div class="holder bottom right"></div>
			</div>
		</div>
	</template>

	<script>
	class XDraggable extends Polymer.Element {
		static get is() {
			return "x-draggable";
		}
		
		constructor() {
			super();
		}
		
		ready() {
			super.ready();
			this.addEventListener("mousedown", this._draginit);
		}
		
		connectedCallback() {
			super.connectedCallback();
		}

		disconnectedCallback() {
			super.disconnectedCallback();
		}
		
		static get properties() {
			return {
				selected : {
					type : Boolean,
					value : false,
					reflectToAttribute : true
				},
				x : {
					type : Number,
					value : 0,
					reflectToAttribute : true,
					observer : "_onChangeX"
				},
				dx : {
					type : Number,
					value : 1,
					reflectToAttribute : true
				},
				y : {
					type : Number,
					value : 0,
					reflectToAttribute : true,
					observer : "_onChangeY"
				},
				dy : {
					type : Number,
					value : 1,
					reflectToAttribute : true
				},
				w : {
					type : Number,
					value : 20,
					reflectToAttribute : true,
					observer : "_onChangeW"
				},
				minw : {
					type : Number,
					value : 10,
					reflectToAttribute : true
				},
				h : {
					type : Number,
					value : 20,
					reflectToAttribute : true,
					observer : "_onChangeH"
				},
				minh : {
					type : Number,
					value : 10,
					reflectToAttribute : true
				},
				z : {
					type : Number,
					value : 0,
					reflectToAttribute : true,
					observer : "_onChangeZ"
				}
			};
		}
		
		_onChangeX(x) {
			let padding = parseInt(getComputedStyle(this).getPropertyValue("padding"));
			this.style.left = `${x-padding}px`;
		}
		
		_onChangeY(y) {
			let padding = parseInt(getComputedStyle(this).getPropertyValue("padding"));
			this.style.top = `${y-padding}px`;
		}
		
		_onChangeW(w) {
			this.w = Math.max(w, this.minw);
			this.$.content.style.width = `${this.w}px`;
		}
		
		_onChangeH(h) {
			this.h = Math.max(h, this.minh);
			this.$.content.style.height = `${this.h}px`;
		}
		
		_onChangeZ(z) {
			this.style.zIndex = z;
		}
		
		//inner-use constants
		static get GRAB_POINT_PADDING() {
			/*
			 * When the mouse leaves the parent and comes back, it immeaditely sets
			 * the new grab point as the edge it entered plus/minus this padding.
			 * This is to avoid the mouse-not-inside-element-while-grabbing glitch.
			 *
			 */
			return 10;
		}
		
		static get SCROLL_RATE() {
			/*
			 * The rate by which the window scrolls when dragging an element
			 * beyond viewport limits.
			 *
			 */
			return 10;
		}
		
		static get SCROLL_TRIGGER_PADDING() {
			/*
			 * Scrolling during drag will be triggered when the mouse is near
			 * the screen edges plus/minus this padding.
			 *
			 */
			return 20;
		}
		
		
		//getters
		get top() {
			return this.y;
		}
		get bottom() {
			return this.y+this.h;
		}
		get left() {
			return this.x;
		}
		get right() {
			return this.x+this.w;
		}
		
		
		//methods
		move(dx, dy) {
			let newX = this.x + dx;
			let newY = this.y + dy;
			
			if (newX < 0) {
				this.x = 0;
			}
			else if (newX+this.w > this.parentElement.offsetWidth) {
				this.x = this.parentElement.offsetWidth - this.w;
			}
			else {
				this.x = newX;
			}
			
			if (newY < 0) {
				this.y = 0;
			}
			else if (newY+this.h > this.parentElement.offsetHeight) {
				this.y = this.parentElement.offsetHeight - this.h;
			}
			else {
				this.y = newY;
			}
		}
		
		_draginit(e) {
			if (e.which !== 1) return;
			
			e.stopPropagation();
			
			let draggable = this;
			
			/* deve ficar no pai */
			if (!draggable.selected && !e.ctrlKey && !e.shiftKey) {
				document.querySelectorAll("x-draggable[selected]")
					.forEach(element => element.selected = false);
			}
			
			draggable.selected = true;
			/* ***************** */
			
			
			let lastPageX = e.pageX;
			let lastPageY = e.pageY;
			let dragging = function(e) {
				if (e.which !== 1) return;
				
				let dx = ((e.pageX - lastPageX)/draggable.dx|0)*draggable.dx;
				let dy = ((e.pageY - lastPageY)/draggable.dy|0)*draggable.dy;
				
				//min and max used for when mouse leaves grid (parent)
				let parentRect = draggable.parentElement.getBoundingClientRect();
				lastPageX = Math.min(Math.max(lastPageX+dx, (parentRect.left+window.scrollX+XDraggable.GRAB_POINT_PADDING)|0), (parentRect.right+window.scrollX-XDraggable.GRAB_POINT_PADDING)|0);
				lastPageY = Math.min(Math.max(lastPageY+dy, (parentRect.top+window.scrollY+XDraggable.GRAB_POINT_PADDING)|0), (parentRect.bottom+window.scrollY-XDraggable.GRAB_POINT_PADDING)|0);
				
				XDraggable.scrollScreen(draggable.getBoundingClientRect());
				
				//criar um x-sandbox para conter os x-draggables
				//notificar o pai que há um evento de drag em andamento para ele tomar as providências de chamar o move em cada elemento selecionado (a seleção pertence ao pai)
				document.querySelectorAll("x-draggable[selected]").forEach( element => element.move(dx, dy) );
			}
			
			window.addEventListener("mousemove", dragging);
			
			window.addEventListener("mouseup", function(e) {
				if (e.which !== 1) return;
				
				e.preventDefault();
				window.removeEventListener("mousemove", dragging);
			});
		}
		
		
		static _onDeselect(e) { //pertence ao pai, na verdade
			document.querySelectorAll("x-draggable[selected]").forEach(element => element.selected = false);
		}
		
		
		static scrollScreen(rect) {
			let scrollX = 0;
			if (rect.right >= window.innerWidth-XDraggable.SCROLL_TRIGGER_PADDING) scrollX = XDraggable.SCROLL_RATE;
			else if (rect.left <= XDraggable.SCROLL_TRIGGER_PADDING) scrollX = -XDraggable.SCROLL_RATE;
			
			let scrollY = 0;
			if (rect.bottom >= window.innerHeight-XDraggable.SCROLL_TRIGGER_PADDING) scrollY = XDraggable.SCROLL_RATE;
			else if (rect.top <= XDraggable.SCROLL_TRIGGER_PADDING) scrollY = -XDraggable.SCROLL_RATE;
			
			window.scrollBy(scrollX,scrollY);
		}
	}
	
	customElements.define(XDraggable.is, XDraggable);
	
	
	document.addEventListener("mousedown", XDraggable._onDeselect); //Pertence ao pai, na verdade
	</script>

</dom-module>