<!-- import polymer-element -->
<link rel="import"  href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">

<link rel="import" href="./x-tabs-item.html">

<dom-module id="x-tabs">

	<template strip-whitespace>
		<style>
		:host {
			display: block;
			contain: content;
		}
		
		#tabs > * {
			display: inline-block;
			cursor: pointer;
			padding: 10px;
			background-color: lightgray;
			border: 1px solid black;
			border-radius: 2px;
		}
		
		#tabs > :not(:first-child) {
			margin-left: 2px;
		}
		
		#tabs > [selected] {
			background-color: whitesmoke;
			cursor: default;
		}
		
		#items {
			margin-top: 6px;
		}
		
		#items ::slotted(*) {
			display: none;
		}
		
		#items ::slotted([selected]) {
			display: block;
		}
		</style>
		
		<div id="container">
			<div id="tabs">
			</div>
			<div id="items">
				<slot id="slot"></slot>
			</div>
		</div>
	</template>

	<script>
	class XTabs extends Polymer.Element {
		static get is() {
			return "x-tabs";
		}

		constructor() {
			super();
		}
		
		ready() {
			super.ready();
		}
		
		connectedCallback() {
			super.connectedCallback();
			
			this._observerChildNode = new Polymer.FlattenedNodesObserver( this, info => {
				this._removeInvalidChildren(info.addedNodes);
				this._bindAddedChildrenListener(info.addedNodes);
				this._bindRemovedChildrenListener(info.removedNodes);
			});
		}

		disconnectedCallback() {
			super.disconnectedCallback();
			this._observerChildNode.disconnect();
		}
		
		_onChangeTabLabel(item) {
			if (item.assignedSlot) {
				let index = Array.prototype.indexOf.call(item.assignedSlot.assignedNodes(), item);
				this.$.tabs.children[index].innerText = item.label;
			}
		}
		
		_onChangeSelectedItem(item) {
			if (item.selected && item.assignedSlot) {
				let index = Array.prototype.indexOf.call(item.assignedSlot.assignedNodes(), item);
				
				for (let node of this.$.tabs.children) { 
					node.removeAttribute("selected");
				}
				
				this.$.tabs.children[index].setAttribute("selected","selected");
			}
		}
		
		_removeInvalidChildren(nodes) {
			nodes
				.filter( item => item.localName !== XTabsItem.is )
				.forEach( item => item.remove() );
		}
		
		_bindAddedChildrenListener(nodes) {
			let selectedItem;
			nodes
				.filter( item => item.localName === XTabsItem.is )
				.forEach( (item, index) => {
					item.addEventListener( "label-changed", e => this._onChangeTabLabel(e.target) );
					item.addEventListener( "selected-changed", e => this._onChangeSelectedItem(e.target) );
					this._createTab( item.label );
					
					if (item.selected) {
						if (selectedItem) {
							item.selected = false;
						}
						else {
							selectedItem = item;
							this.$.tabs.children[index].setAttribute("selected","selected");
						}
					}
				});
		}
		
		_bindRemovedChildrenListener(nodes) {
			nodes
				.filter( item => item.localName === XTabsItem.is )
				.forEach( item => {
					let index = Array.prototype.indexOf.call(item.assignedSlot.assignedNodes(), item);
					this.$.tabs.children[index].remove();
				});
		}
		
		_createTab(label) {
			let tab = document.createElement("label");
			tab.innerText = label;
			tab.addEventListener("click", e => {
				let selectedTab = e.target;
				let index = Array.prototype.indexOf.call(this.$.tabs.children, selectedTab);
				
				this.$.slot.assignedNodes()
					.filter( item => item.selected )
					.forEach( item => item.selected = false );
				
				this.$.slot.assignedNodes()[index].selected = true;
			});
			
			this.$.tabs.appendChild(tab);
		}
	}

	customElements.define(XTabs.is, XTabs);
	</script>

</dom-module>